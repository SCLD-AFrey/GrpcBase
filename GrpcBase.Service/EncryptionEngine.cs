using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using DidiSoft.OpenSsl;
using DidiSoft.OpenSsl.Rsa;
using DidiSoft.OpenSsl.X509;
using SteelCloud.FilesAndFolders;

namespace GrpcBase.Service.Encryption
{
    /// <summary>
    /// A class containing cryptographic encryption functions.
    /// </summary>
    public class EncryptionEngine
    {
        /// <summary>
        /// Generates a cryptographically generated byte array for use as a salt in hash generation.
        /// </summary>
        /// <param name="p_saltLength">Defines the size of the byte array to fill with the salt values.</param>
        /// <returns>An array of bytes to use as a salt.</returns>
        public byte[] GenerateSalt(int p_saltLength)
        {
            var saltBytes = new byte[p_saltLength];
            using var rng = new RNGCryptoServiceProvider();

            rng.GetBytes(saltBytes);

            return saltBytes;
        }

        /// <summary>
        /// Generates a cryptographic hash from an input string.
        /// </summary>
        /// <param name="p_inputString">The string from which to derive the cryptographic hash.</param>
        /// <param name="p_saltBytes">The salt to use during hash generation.</param>
        /// <param name="p_iterations">The number of iterations to run to generate the cryptographic hash. More iterations take more time, but generate a more secure hash.</param>
        /// <param name="p_hashLength">The number of bytes to generate for the cryptographic hash.</param>
        /// <returns>A cryptographic hash derived from the input string.</returns>
        public byte[] GenerateCryptoHash(string p_inputString, byte[] p_saltBytes, int p_iterations, int p_hashLength)
        {
            using var byteGenerator = new Rfc2898DeriveBytes(p_inputString, p_saltBytes, p_iterations);
            return byteGenerator.GetBytes(p_hashLength);
        }

        /// <summary>
        /// Gets a hex-formatted string from an array of bytes.
        /// </summary>
        /// <param name="p_byteArray">A byte array from which to derive the output string.</param>
        /// <returns>A hex-formatted string representing an array of bytes.</returns>
        public string GetHexStringFromByteArray(byte[] p_byteArray)
        {
            return BitConverter.ToString(p_byteArray).Replace("-", string.Empty);
        }

        /// <summary>
        /// Gets an array of bytes from their string representation.
        /// </summary>
        /// <param name="p_hexString">A string of bytes in hex form.</param>
        /// <returns>An array of byte values.</returns>
        public byte[] GetByteArrayFromHexString(string p_hexString)
        {
            var numberOfChars = p_hexString.Length;
            var bytes = new byte[numberOfChars / 2];
            for (var i = 0; i < numberOfChars; i += 2)
                bytes[i / 2] = Convert.ToByte(p_hexString.Substring(i, 2), 16);
            return bytes;
        }

 

        /// <summary>
        /// Generates a new RSA key pair.
        /// </summary>
        /// <param name="p_keyLength">The length of the RSA key to be generated.</param>
        /// <returns>An RSA keypair.</returns>
        public KeyPair GenerateNewAsymmetricRsaKeyPair(KeyLength p_keyLength)
        {
            var rsa = new OpenSslRsa();
            return rsa.GenerateRsaKeyPair(p_keyLength);
        }

        /// <summary>
        /// Generates an x509Certificate2 from an RSA key pair.
        /// </summary>
        /// <param name="p_keyPair">An RSA key pair from which to generate the certificate.</param>
        /// <param name="p_keyFriendlyName">The name of the certificate store to access.</param>
        /// <returns>An X509Certificate2 with associated public and private keys</returns>
        public X509Certificate2 GenerateX509Certificate2FromRsaKeyPair(KeyPair p_keyPair, string p_keyFriendlyName)
        {
            var properties = new X509Name()
            {
                CommonName = p_keyFriendlyName,
                CountryCode = "US",
                State = "VA",
                Locality = "Ashburn",
                EmailAddress = "mheimlich@steelcloud.com"
            };

            // Create certificate via OpenSSL. - Comment by Matt Heimlich on 05/23/2020 @ 19:41:28
            var newCert = Certificate.CreateSelfSignedCertificate(p_keyPair.Public, p_keyPair.Private, properties);
            // Generate X509Certificate2 object from generated OpenSSL certificate. - Comment by Matt Heimlich on 05/23/2020 @ 19:41:44
            var x509Cert = newCert.ToX509Certificate2();
            // Store generated RSA key in X509Certificate2. - Comment by Matt Heimlich on 05/23/2020 @ 19:42:45
            var newStorageCert = x509Cert.CopyWithPrivateKey(p_keyPair.Private.ToAsymmetricAlgorithm() as RSA);

            const X509KeyStorageFlags storageFlags = X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable;

            // Generate final certificate to be saved using property storage flags to allow for key export and store persistence. - Comment by Matt Heimlich on 05/23/2020 @ 19:43:02
            var certWithPersistedKey =
                new X509Certificate2(
                    newStorageCert.Export(X509ContentType.Pkcs12, "P@ssw0rd"),
                    "P@ssw0rd",
                    storageFlags);

            return certWithPersistedKey;
        }

        /// <summary>
        /// Writes out an X509Certificate2 object to a PKCS12 formatted storage file.
        /// </summary>
        /// <param name="p_certificate">The certificate to be exported.</param>
        /// <param name="p_filePath">The file path to which to export the PKCS12 key file.</param>
        /// <param name="p_keyFilePassword">A SecureString representation of the PKCS12 key's password.</param>
        public void SaveX509Certificate2ToFile(X509Certificate2 p_certificate, string p_filePath,
            SecureString p_keyFilePassword)
        {
            var formattedCert = p_certificate.Export(X509ContentType.Pkcs12, p_keyFilePassword);
            File.WriteAllBytes(p_filePath, formattedCert);
        }

        /// <summary>
        /// Loads a PKCS12 formatted key into an X509Certificate2 object.
        /// </summary>
        /// <param name="p_keyFilePath">The file path to the key to be loaded.</param>
        /// <param name="p_keyFilePassword">A SecureString representation of the PKCS12 key's password.</param>
        /// <returns>An X509Certificate2 with the public and private RSA keys associated with the input PKCS12 key.</returns>
        public X509Certificate2 LoadX509Certificate2FromFile(string p_keyFilePath, SecureString p_keyFilePassword)
        {
            var storageFlags = X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable;
            return new X509Certificate2(p_keyFilePath, p_keyFilePassword, storageFlags);
        }

 

        /// <summary>
        /// Stores an X509Certificate2 in the key store.
        /// </summary>
        /// <param name="p_certificate">The certificate to be stored.</param>
        /// <exception cref="CryptographicException"></exception>
        private void StoreX509Certificate2InX509Store(X509Certificate2 p_certificate)
        {
            var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            try
            {
                store.Open(OpenFlags.ReadWrite);
                store.Add(p_certificate);
            }
            catch (Exception exception)
            {
                throw new CryptographicException($"Could not store certificate: {exception.Message}");
            }
            finally
            {
                store.Close();
            }
        }



        /// <summary>
        /// Creates the system directory necessary to house the thumbprint store.
        /// </summary>
        private void CreateStoreLocation()
        {
            var checkPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                "scdata");
            FolderUtilities.SafeCreateFolder(checkPath);
        }




        /// <summary>
        /// Finds and returns the certificate in the X509Store matching the given thumbprint value.
        /// </summary>
        /// <param name="p_thumbprint">A certificate thumbprint for which to search</param>
        /// <returns>The certificate matching the given thumbprint</returns>
        /// <exception cref="KeyNotFoundException"></exception>
        private X509Certificate2 LoadX509Certificate2FromThumbprint(string p_thumbprint)
        {
            if (!CertificateExistsInStore(p_thumbprint))
                throw new KeyNotFoundException(
                    $"A certificate count not be found matching thumbprint '{p_thumbprint}'");

            var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadOnly);
            try
            {
                var certificates = store.Certificates.Find(X509FindType.FindByThumbprint, p_thumbprint, false);
                return certificates[0];
            }
            finally
            {
                store.Close();
            }

        }


        private void RemoveX509Certificate2FromStore(string p_thumbprint)
        {
            if (!CertificateExistsInStore(p_thumbprint))
                throw new KeyNotFoundException(
                    $"Certificate with thumbprint '{p_thumbprint}' could not be found for removal");

            var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            store.Open(OpenFlags.ReadWrite);
            try
            {
                var matchingCerts = store.Certificates.Find(X509FindType.FindByThumbprint, p_thumbprint, false);
                store.Remove(matchingCerts[0]);
            }
            finally
            {
                store.Close();
            }
        }




        private bool CertificateExistsInStore(string p_thumbprint)
        {
            var store = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            try
            {
                store.Open(OpenFlags.ReadOnly);
                return store.Certificates.Find(X509FindType.FindByThumbprint, p_thumbprint, false).Count > 0;
            }
            catch
            {
                return false;
            }
            finally
            {
                store.Close();
            }
        }



        /// <summary>
        /// Randomly scrambles the characters in a string.
        /// </summary>
        /// <param name="p_inputString">The string to scramble.</param>
        /// <param name="p_seed">The seed to use for the random scramble. Must be the same as the seed used to unscramble to get the original string back.</param>
        /// <returns>A scrambled version of the input string.</returns>
        public static string BasicScrambleString(string p_inputString, int p_seed)
        {
            var chars = p_inputString.ToArray();
            var r = new Random(p_seed);
            for (var i = 0; i < chars.Length; i++)
            {
                var randomIndex = r.Next(0, chars.Length);
                var temp = chars[randomIndex];
                chars[randomIndex] = chars[i];
                chars[i] = temp;
            }

            return new string(chars);
        }

        /// <summary>
        /// Unscrambles a string.
        /// </summary>
        /// <param name="p_inputString">The scrambled string to unscramble.</param>
        /// <param name="p_seed">The seed to use for the unscramble. Must be the same as the seed used to scramble to get the original string back.</param>
        /// <returns>An unscrambled string.</returns>
        public static string BasicUnscrambleString(string p_inputString, int p_seed)
        {
            var scrambledChars = p_inputString.ToArray();
            var r = new Random(p_seed);

            var swaps = scrambledChars.Select(p_t => r.Next(0, scrambledChars.Length)).ToList();

            for (var i = scrambledChars.Length - 1; i >= 0; i--)
            {
                var temp = scrambledChars[swaps[i]];
                scrambledChars[swaps[i]] = scrambledChars[i];
                scrambledChars[i] = temp;
            }

            return new string(scrambledChars);
        }

        public string EncodeBytesToBase64String(byte[] p_bytes)
        {
            return Convert.ToBase64String(p_bytes);
        }

        public byte[] DecodeBase64StringToBytes(string p_encodedData)
        {
            return Convert.FromBase64String(p_encodedData);
        }

        public string GenerateNewHashId()
        {
            var newSalt = GenerateSalt(12);
            return GetHexStringFromByteArray(newSalt);
        }

        public string GetSha256Checksum(string p_inputFile)
        {
            using var stream = File.OpenRead(p_inputFile);
            var sha = new SHA256Managed();
            var checksum = sha.ComputeHash(stream);
            return GetHexStringFromByteArray(checksum);
        }

        public static SecureString StringToSecureString(string p_inputString)
        {
            var secureString = new SecureString();
            foreach (var character in p_inputString)
            {
                secureString.AppendChar(character);
            }

            return secureString;
        }

        public static string SecureStringToString(SecureString p_value)
        {
            var byteStream = Marshal.SecureStringToBSTR(p_value);

            try
            {
                return Marshal.PtrToStringBSTR(byteStream);
            }
            finally
            {
                Marshal.FreeBSTR(byteStream);
            }
        }
    }
}
